using Cysharp.Threading.Tasks;
using DG.Tweening;
using Minigames.MatrixBreaching.Config;
using Minigames.MatrixBreaching.Matrix.Data;
using Minigames.MatrixBreaching.Vulnerabilities.Models;
using TMPro;
using UniRx;
using UnityEngine;
using Zenject;

namespace Minigames.MatrixBreaching.Vulnerabilities.Views
{
    public class VulnerabilityView : MonoBehaviour
    {
        public RectTransform Transform => _transform == null ? GetComponent<RectTransform>() : _transform;
        public VulnerabilityModel Model => _vulnerabilityModel;
        public bool IsInitialized => _vulnerabilityModel != null;

        [SerializeField] private Transform _cellViewsHolder;
        [SerializeField] private TextMeshProUGUI _vulnerabilityBreachDamageText;
        private VulnerabilityModel _vulnerabilityModel;
        private DiContainer _container;
        private MatrixBreachingViewConfig _viewConfig;

        private VulnerabilityCellView[] _vulnerabilityCellViews;
        private RectTransform _transform;
        private CompositeDisposable _compositeDisposable = new CompositeDisposable();
        private Tween _hideAnimation;

        private void Awake()
        {
            _transform = GetComponent<RectTransform>();
        }

        [Inject]
        private void Construct(DiContainer container, MatrixBreachingViewConfig viewConfig)
        {
            _viewConfig = viewConfig;
            _container = container;
        }
        public async void Initialize(VulnerabilityModel vulnerabilityModel)
        {
            _vulnerabilityModel = vulnerabilityModel;

            _vulnerabilityBreachDamageText.text = $"+{_vulnerabilityModel.BreachDamage}";
            if (!_vulnerabilityModel.IsInitialized)
                await UniTask.WaitUntil(() => _vulnerabilityModel.IsInitialized);
            
            _vulnerabilityCellViews = new VulnerabilityCellView[_vulnerabilityModel.SequenceSize];
            for (int i = 0; i < _vulnerabilityModel.SequenceSize; i++)
            {
                _vulnerabilityCellViews[i] = InitCellView(_vulnerabilityModel.VulnerabilitySequence[i]);
            }

            _vulnerabilityModel.MatchedSize.Subscribe(matchedSize => UpdateCellsHighlight(matchedSize))
                .AddTo(_compositeDisposable);
        }

        public async UniTask HideAnimation()
        {
            if (_hideAnimation.IsActive())
            {
                await _hideAnimation.AsyncWaitForKill();
                return;
            }
            
            _compositeDisposable.Clear();
            var endAnchorPos = _transform.anchoredPosition.x + _transform.sizeDelta.x * 1f;
            _hideAnimation = _transform.DOAnchorPosX(endAnchorPos, 0.45f).SetEase(Ease.OutSine);
            await _hideAnimation.AsyncWaitForKill();
        }

        private void UpdateCellsHighlight(int matchedSize)
        {
            for (int i = 0; i < _vulnerabilityCellViews.Length; i++)
            {
                _vulnerabilityCellViews[i].SetHighlightActive( i < matchedSize);
            }
        }

        private VulnerabilityCellView InitCellView(CellValueType cellValue)
        {
            var cellView = _container.InstantiatePrefabForComponent<VulnerabilityCellView>(_viewConfig.VulnerabilityCellViewTemplate,
                _cellViewsHolder);
            cellView.Initialize(cellValue);
            return cellView;
        }

        private void OnDestroy()
        {
            _hideAnimation?.Kill();
        }
    }
}