using System;
using System.Collections.Generic;
using System.Linq;
using Minigames.MatrixBreaching.Matrix.Data;
using Minigames.MatrixBreaching.Matrix.Models;
using Minigames.MatrixBreaching.Vulnerabilities.Models;

namespace Minigames.MatrixBreaching.Vulnerabilities.Services
{
    public class VulnerabilityService
    {
        private readonly VulnerabiltyInventory _vulnerabiltyInventory;
        private Random _random;
        private GuardMatrix _matrix;

        public VulnerabilityService(VulnerabiltyInventory vulnerabiltyInventory, GuardMatrix matrix)
        {
            _matrix = matrix;
            _vulnerabiltyInventory = vulnerabiltyInventory;
        }
        public VulnerabilityModel CreateNewVulnerability(int length)
        {
            var cells = _matrix.GetCells();
            var selectedCellsSequence = cells.Where(cell => cell is ValueCell)
                .OrderBy(_ => _random.Next())
                .Take(length)
                .Select(cell => ((ValueCell)cell))
                .ToList();
            
            var vulnerabilitySequence = selectedCellsSequence
                .Select(cell => cell.Value)
                .ToList();
            
            return _vulnerabiltyInventory.CreateNewModel(vulnerabilitySequence, out var _);
        }

        public bool FindCompletedVulnerabilities(out IList<VulnerabilityModel> foundVulnerabilites)
        {
            foundVulnerabilites = _vulnerabiltyInventory.Where(model => model.IsVulnerabilityCompleted.Value).ToList();
            return foundVulnerabilites.Count > 0;
        }
        
        public void SetRandomSeed(int seed)
        {
            _random = new Random(seed);
        }

        public IList<ValueCell> FindBestMatchForVulnerability(VulnerabilityModel model)
        {
            if (!model.IsInitialized)
                return new List<ValueCell>();
            var compareValue = model.VulnerabilitySequence.First();
            var foundOptions = _matrix.GetCells()
                .Where(cell => cell is ValueCell valueCell && valueCell.Value == compareValue)
                .Select(valueCell => FindSequenceWithCell((ValueCell)valueCell, model.VulnerabilitySequence)).ToList();
            
            return foundOptions.OrderByDescending(option => option.Count).FirstOrDefault();
        }

        private IList<ValueCell> FindSequenceWithCell(ValueCell valueCell, IList<CellValueType> sequence)
        {
            var foundSequence = new List<ValueCell>();
            FindMatrixCombination(valueCell, sequence, 1, ref foundSequence);
            return foundSequence;
        }
        private void FindMatrixCombination(ValueCell cell,  IList<CellValueType> sequence, int currentIndex,
            ref List<ValueCell> resultCells, int filter = -1)
        {
            resultCells.Add(cell);
            if (currentIndex >= sequence.Count)
                return;

            var compareValue = sequence[currentIndex];
            var x = cell.HorizontalId;
            var y = cell.VerticalId;

            var rightBranch = resultCells.ToList();
            if (filter != 1 && x + 1 < _matrix.Size.x && _matrix.GetCell(x + 1, y) is ValueCell rightCell &&
                rightCell.Value == compareValue)
            {
                FindMatrixCombination(rightCell, sequence, currentIndex + 1, ref rightBranch, 0);
            }
            var leftBranch = resultCells.ToList();
            if (filter != 0 && x - 1 >= 0 && _matrix.GetCell(x - 1, y) is ValueCell leftCell && leftCell.Value == compareValue)
            {
                FindMatrixCombination(leftCell, sequence, currentIndex + 1, ref leftBranch, 1);
            }
            var topBranch = resultCells.ToList();
            if (filter != 3 && y + 1 < _matrix.Size.y && _matrix.GetCell(x, y + 1) is ValueCell topCell && topCell.Value == compareValue)
            {
                FindMatrixCombination(topCell, sequence, currentIndex + 1, ref topBranch, 2);
            }
            var bottomBranch = resultCells.ToList();
            if (filter != 2 && y - 1 >= 0 && _matrix.GetCell(x, y - 1) is ValueCell bottomCell && bottomCell.Value == compareValue)
            {
                FindMatrixCombination(bottomCell, sequence, currentIndex + 1, ref bottomBranch, 3);
            }

            resultCells = new[] { leftBranch, rightBranch, topBranch, bottomBranch }
                .OrderByDescending(branch => branch.Count).First();
        }
    }
}