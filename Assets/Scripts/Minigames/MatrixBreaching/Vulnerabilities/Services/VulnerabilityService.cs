using System;
using System.Collections.Generic;
using System.Linq;
using JetBrains.Annotations;
using Minigames.MatrixBreaching.Matrix.Data;
using Minigames.MatrixBreaching.Matrix.Interfaces;
using Minigames.MatrixBreaching.Matrix.Models;
using Minigames.MatrixBreaching.Matrix.Models.Cells;
using Minigames.MatrixBreaching.Vulnerabilities.Models;

namespace Minigames.MatrixBreaching.Vulnerabilities.Services
{
    public class VulnerabilityService : IReqiureRandomSeed
    {
        private readonly VulnerabiltyInventory _vulnerabiltyInventory;
        private Random _random;
        private GuardMatrix _matrix;

        public VulnerabilityService(VulnerabiltyInventory vulnerabiltyInventory, GuardMatrix matrix)
        {
            _matrix = matrix;
            _vulnerabiltyInventory = vulnerabiltyInventory;
        }
        public VulnerabilityModel CreateNewVulnerability(int length)
        {
            var valueCells = _matrix.GetCells()
                .Where(cell => cell is ValueCell).ToList();
            List<CellValueType> vulnerabilitySequence;
            var maxTries = 30;
            var currentTry = 0;
            do
            {
                vulnerabilitySequence = valueCells
                    .OrderBy(_ => _random.Next())
                    .Take(length)
                    .Select(cell => ((ValueCell)cell).Value)
                    .ToList();
                var foundMatch = FindBestMatchForVulnerabilitySequence(vulnerabilitySequence);
                if (foundMatch.Count < vulnerabilitySequence.Count)
                    break;
            } while (currentTry++ < maxTries);
            
            return _vulnerabiltyInventory.CreateNewModel(vulnerabilitySequence, out var _);
        }

        public bool FindCompletedVulnerabilities(out IList<VulnerabilityModel> foundVulnerabilites)
        {
            foundVulnerabilites = _vulnerabiltyInventory.Where(model => model.IsVulnerabilityCompleted.Value).ToList();
            return foundVulnerabilites.Count > 0;
        }
        
        public void SetRandomSeed(int seed)
        {
            _random = new Random(seed);
        }

        public IList<ValueCell> FindBestMatchForVulnerabilitySequence([NotNull] List<CellValueType> VulnerabilitySequence)
        {

            var compareValue = VulnerabilitySequence.First();
            var foundOptions = _matrix.GetCells()
                .Where(cell => cell is ValueCell valueCell && valueCell.Value == compareValue)
                .Select(valueCell => FindSequenceWithCell((ValueCell)valueCell, VulnerabilitySequence)).ToList();

            if (foundOptions.Any())
                return foundOptions.OrderByDescending(option => option.Count).First();
            else
                return new List<ValueCell>();
        }

        private IList<ValueCell> FindSequenceWithCell(ValueCell valueCell, IList<CellValueType> sequence)
        {
            var foundSequence = new List<ValueCell>();
            FindMatrixCombination(valueCell, sequence, 1, ref foundSequence);
            return foundSequence;
        }
        private void FindMatrixCombination(ValueCell cell,  IList<CellValueType> sequence, int currentIndex,
            ref List<ValueCell> resultCells, int filter = -1)
        {
            resultCells.Add(cell);
            if (currentIndex >= sequence.Count)
                return;

            var compareValue = sequence[currentIndex];
            var x = cell.HorizontalId;
            var y = cell.VerticalId;

            var rightBranch = resultCells.ToList();
            if (filter != 1 && x + 1 < _matrix.Size.x && _matrix.GetCell(x + 1, y) is ValueCell rightCell &&
                rightCell.Value == compareValue)
            {
                FindMatrixCombination(rightCell, sequence, currentIndex + 1, ref rightBranch, 0);
            }
            var leftBranch = resultCells.ToList();
            if (filter != 0 && x - 1 >= 0 && _matrix.GetCell(x - 1, y) is ValueCell leftCell && leftCell.Value == compareValue)
            {
                FindMatrixCombination(leftCell, sequence, currentIndex + 1, ref leftBranch, 1);
            }
            var topBranch = resultCells.ToList();
            if (filter != 3 && y + 1 < _matrix.Size.y && _matrix.GetCell(x, y + 1) is ValueCell topCell && topCell.Value == compareValue)
            {
                FindMatrixCombination(topCell, sequence, currentIndex + 1, ref topBranch, 2);
            }
            var bottomBranch = resultCells.ToList();
            if (filter != 2 && y - 1 >= 0 && _matrix.GetCell(x, y - 1) is ValueCell bottomCell && bottomCell.Value == compareValue)
            {
                FindMatrixCombination(bottomCell, sequence, currentIndex + 1, ref bottomBranch, 3);
            }

            resultCells = new[] { leftBranch, rightBranch, topBranch, bottomBranch }
                .OrderByDescending(branch => branch.Count).First();
        }
    }
}